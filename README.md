# supercollider-interserver-bus

This is a work in progress. And needless to say, very experimental.

This plugin provides two UGens: `ISIn.ar` and `ISOut.ar`. Together with `ISBus` you can write and read from busses that are in shared memory, allowing multiple `scsynth` servers running on the same machine to send audio signals to each other.

The main motivation for this was to be able to have multiple SC servers running with different blockSize, sampleRate and other options, and still be able to send audio between then. This way you can have a single sample process running on one server and route it to the "main" server to process, play, etc.

## Example

New version with ISNdef, a convinience to create an ndef on a special blockSize=1 server and mirroring its parameters in a local ndef:
```supercollider
(
ISNdef(\xfm, { arg freqA = 32, freqB = 9, modAtoB=540, modBtoA=240;
	var fbIn = LocalIn.ar(2);
	var sigs = SinOsc.ar([freqA, freqB] + (fbIn.reverse * [modBtoA, modAtoB]));
	LocalOut.ar(sigs);
	sigs*0.5;
});
)
(
ISNdef(\xfm).addSpec(\freqA, [0.01, 20000, \exp]);
ISNdef(\xfm).addSpec(\freqB, [0.01, 20000, \exp]);
ISNdef(\xfm).addSpec(\modAtoB, [0,1000]);
ISNdef(\xfm).addSpec(\modBtoA, [0,1000]);
)
```

Or a more general using the ISOut, ISIn and ISBus:

A crossfeedback FM (from https://scsynth.org/t/cybernetic-music-with-supercollider/3184/3) running on a server with `blockSize = 1` and sending its signal via `ISBus`.

Notice that `Ndef(\listen)` is running on the default server and listening to the signal generated by the `\singleSample` server.

There is a default delay of 2048 samples on the bus. This is delay is configurable and depends on your hardware / audio engine buffer size.

```supercollider
(
s.waitForBoot {
	z = Server.new(\singleSample, NetAddr("127.0.0.1", 57140));
	z.options.blockSize = 1;
	z.waitForBoot {
		Ndef(\singleSampleXFM -> \singleSample).addSpec(\freqA, [0.01, 20000, \exp]);
		Ndef(\singleSampleXFM -> \singleSample).addSpec(\freqB, [0.01, 20000, \exp]);
		Ndef(\singleSampleXFM -> \singleSample).addSpec(\modAtoB, [0,1000]);
		Ndef(\singleSampleXFM -> \singleSample).addSpec(\modBtoA, [0,1000]);
		Ndef(\singleSampleXFM -> \singleSample).addSpec(\delayedSamples, [0,2, \lin, 1]);
		
		Ndef(\singleSampleXFM -> \singleSample, { arg freqA = 32, freqB = 9, modAtoB=540, modBtoA=240, delayedSamples;
			var fbIn = LocalIn.ar(2);
			var sigs = SinOsc.ar([freqA, freqB] + (fbIn.reverse * [modBtoA, modAtoB]));
			LocalOut.ar(
				Select.ar(delayedSamples, [
					sigs,
					Delay1.ar(sigs),
					Delay2.ar(sigs)
				]);
			);
			ISOut.ar(0, sigs * 0.5);
		}).gui;
		
		Ndef(\listen, {
			ISIn.ar(0, 2);
		}).gui;
	}
};
)
```

### Requirements

- CMake >= 3.12
- SuperCollider source code

### Building

Clone the project:

    git clone https://github.com/bgola/supercollider-interserver-bus
    cd supercollider-interserver-bus
    mkdir build
    cd build

Then, use CMake to configure and build it:

    cmake .. -DCMAKE_BUILD_TYPE=Release
    cmake --build . --config Release
    cmake --build . --config Release --target install

You may want to manually specify the install location in the first step to point it at your
SuperCollider extensions directory: add the option `-DCMAKE_INSTALL_PREFIX=/path/to/extensions`.

It's expected that the SuperCollider repo is cloned at `../supercollider` relative to this repo. If
it's not: add the option `-DSC_PATH=/path/to/sc/source`.
